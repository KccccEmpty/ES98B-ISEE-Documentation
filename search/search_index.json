{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>This project provides a satellite orbital decay simulation and a prediction system, designed to model and predict the trajectory of a satellite (ISEE-3) entering Earth\u2019s atmosphere along an equatorial orbit.</p>"},{"location":"#primary-objectives","title":"Primary objectives:","text":"<ul> <li>Assist users in setting up the environment, indicate reasonable use cases and how to launch and vary the simulation to produce visualisations.</li> <li>Guide developers to understand how to extend the functionality for advanced use cases.</li> </ul>"},{"location":"#key-package-features","title":"Key package features:","text":"<ul> <li>Configurable orbital decay simulation based on popular physical models and assumptions:</li> <li>Spherical Earth, uniform density, constant rotation.</li> <li>Time-invariant satellite surface area, non-rotating around any of its axes.</li> <li>U.S. Standard Atmosphere 1976 model.</li> <li>Isolated system (Earth and satellite).</li> <li>Radar-based state estimation using a configurable Extended Kalman Filter (EKF).</li> </ul>"},{"location":"#limitations-current-known-issues","title":"Limitations &amp; current known issues","text":"<ul> <li>A spherical Earth with uniform density is assumed.</li> <li>Assumes constant surface area and a non-tumbling satellite.</li> <li>Assumes the drag equation is valid from start to end - does not consider non-continuum effects above 86km.</li> <li>Constant radar noise model (no occlusion or range bias).</li> <li>EKF-based filtering (prone to numerical instability).</li> <li>Uncertainty quantification based on Monte Carlo sampling; computationally expensive for large sample sizes.</li> </ul>"},{"location":"cfg/","title":"Comprehensive Functionality Guide","text":"<p>This section is intended for understanding how to modify or extend the internal structure of the system.</p> <p>It describes:</p> <ul> <li>The package architecture and the data exchanges between modules.</li> <li>Key functions within each module and their customisation.</li> </ul>"},{"location":"cfg/#1-system-architecture","title":"1. System Architecture","text":"<pre><code>SkyFall\n\u2502\n\u251c\u2500\u2500 main.py                     # Example script: run simulation and prediction\n\u251c\u2500\u2500 requirements.txt            # Python dependency list\n\u251c\u2500\u2500 README.md                   # Project overview and instructions\n\u2502\n\u251c\u2500\u2500 SkyFall/                    # Main source package\n\u2502\n\u2502   \u251c\u2500\u2500 simulator/\n\u2502       \u2514\u2500\u2500 simulator.py        # Orbital dynamics + radar measurement simulation\n\u2502\n\u2502   \u251c\u2500\u2500 predictor/\n\u2502       \u2514\u2500\u2500 predictor.py        # EKF-based state estimation and impact prediction\n\u2502\n\u2502   \u251c\u2500\u2500 visualiser/\n\u2502       \u2514\u2500\u2500 visualiser.py       # Trajectory plotting and HTML report generation\n\u2502\n\u2502   \u251c\u2500\u2500 utils/\n\u2502       \u251c\u2500\u2500 global_variables.py    # Physical constants (G, Re, \u03c9, etc.)\n\u2502       \u251c\u2500\u2500 analytical_F.py        # \u2202f/\u2202x Jacobian for EKF state transition\n\u2502       \u251c\u2500\u2500 analytical_H.py        # \u2202h/\u2202x Jacobian for EKF observation model\n\u2502       \u251c\u2500\u2500 predictor_utilities.py # State propagation + RK4 for EKF\n\u2502       \u2514\u2500\u2500 __init__.py            # Python package initializer\n\u2502\n\u2502   \u2514\u2500\u2500 __init__.py             # Python package initializer\n\n</code></pre> Module Responsibility <code>simulator/</code> Simulates satellite motion and radar observations <code>predictor/</code> Applies EKF to estimate trajectory and impact site via Monte Carlo sampling <code>visualisation/</code> Generates plots and terminal outputs from prediction <code>utils/</code> Stores shared constants, symbolic Jacobians, etc. <p>The main script <code>main.py</code> calls these modules sequentially, handling data flow and integration logic. See tutorial for a worked example.</p> <ol> <li>Using Individual Modules</li> </ol>"},{"location":"cfg/#2-simulatorpy","title":"2. <code>Simulator.py</code>:","text":"<p>Simulator (Class)</p> <ul> <li>inputs:</li> <li><code>initial_state</code>: np.array,<ul> <li>This specifies the starting point of the satellite from the moment it begins experiencing orbital decay.</li> </ul> </li> <li><code>measurement_covariance</code>: np.array,<ul> <li>This specifies a constant matrix R. This is the noise corrupting truth of measured attributes of the satellite.</li> </ul> </li> <li><code>timestep</code>: float,<ul> <li> <ul> <li>Timestep for the numerical method RK45.</li> </ul> </li> </ul> </li> <li><code>t0</code>: float = 0,<ul> <li>Starting point in time.</li> </ul> </li> <li><code>t_end</code>: float = 4e9<ul> <li>An unreasonably large value (~127 years) on which to end the simulation. This ensures the measurements till the satellite crashes are captured.</li> </ul> </li> </ul> <p>get_measurements (function)</p> <ul> <li>inputs:</li> <li><code>Verbose</code>: Bool<ul> <li>This signposts the calling, the beginning and end of execution of the function.</li> </ul> </li> <li>outputs:</li> <li><code>times</code>: np.array,<ul> <li>The times for which the ODE was numerically stepped through.</li> </ul> </li> <li><code>measurement_noiseless</code>: np.array,<ul> <li>The 'real' radar station measurements (i.e. no noise).</li> </ul> </li> <li><code>measurement_noise</code>: np.array,<ul> <li>The radar station measurements perturbed with additive Gaussian noise.</li> </ul> </li> <li><code>active_radar_stations_per_time</code>: np.array,<ul> <li>A history of active radar stations per time step by index.</li> </ul> </li> <li><code>active_radar_station_longitudes_per_time</code>: np.array,<ul> <li>A history of active radar stations' longitudes per time.</li> </ul> </li> <li><code>crash_site</code>: np.array,<ul> <li>Given the tranquillity base condition on the computed standard deviation of the periodic ODE propagated Monte Carlo trajectories, this would be their mean at r=R_E.</li> </ul> </li> <li><code>crash_time[0]</code>: float,<ul> <li>This is the time elapsed since the start of simulation, added by the time at which the tranquillity base condition was satisfied by the ODE propagated MC trajectories.</li> </ul> </li> <li><code>state_noiseless.T</code>: np.array,<ul> <li>The trajectory of the state vector through the dynamics of the ODE system.</li> </ul> </li> </ul>"},{"location":"cfg/#3-predictorpy","title":"3. <code>Predictor.py</code>:","text":"<p>Predictor (class)</p> <p>process_model (function): Obtain the prior state, at time $t$, mean by passing the posterior random variable, from time $t-\\Delta t$ through the ODE and a sample is taken from a Gaussian random variable, </p> <ul> <li>Inputs:</li> <li><code>posterior_state</code>: np.array<ul> <li>This is the posterior covariance matrix obtained from the previous iteration $\\bar{P}{t-\\Delta t}$ / or the initial posterior covariance matrix $P{0}$.</li> </ul> </li> <li><code>process_covariance</code>: np.array<ul> <li>This is the process covariance matrix $Q$. This is a measure of our \u2018belief\u2019 in the physics/ in the validity of the model of the dynamics</li> </ul> </li> <li><code>timestep</code>: float<ul> <li>This is the timestep used in the numerical finite difference method when evaluating the Jacobian of the continuous physics ODE dynamics, $f(.)$, $F_{t}(.)$</li> </ul> </li> <li><code>t</code>: float<ul> <li>This is the time elapsed till after the last timestep was taken</li> </ul> </li> <li><code>include_noise</code>: Bool<ul> <li>If true, $+Q$ else $+ 0$</li> </ul> </li> <li><code>verbose</code>: Bool<ul> <li>If true, print outputs of the process model to the terminal, else don\u2019t</li> </ul> </li> <li>Outputs:</li> <li><code>predicted_state_with_noise</code>: np.array<ul> <li>$\\bar{P}t = F_t \\,P{t-\\Delta t}\\, F_t^T + Q$</li> </ul> </li> <li><code>predicted_state_without_noise</code>: np.array<ul> <li>$\\bar{P}t = F_t \\,P_{t-\\Delta t}\\, F_t^T$</li> </ul> </li> </ul> <p>measurement_model() (function): Converts state into measurement space for residual calculation</p> <ul> <li>Inputs:</li> <li><code>prior_state</code>: np.array<ul> <li>This is the (with noise/ without noise) output of the process model</li> </ul> </li> <li><code>theta_R</code>: float<ul> <li>This is the longitude of the \u2018active\u2019 satellite determined by the simulator during the satellite descent</li> </ul> </li> <li><code>t</code> : float<ul> <li>The current time in the Earth-satellite system</li> </ul> </li> <li>Outputs:</li> <li><code>h</code> :<ul> <li>The projection of the state vector into measurement space, $[r,\\dot{r}]$</li> </ul> </li> </ul> <p>eval_JacobianF() (function): Computes matrix of partial derivatives for continuous ODE system, pre-calculated and stored in \\utils, evaluating at current state to propagate prior state covariance</p> <ul> <li>Inputs:</li> <li><code>G, M_e, Cd, A, m, R_star, g0, M_molar, omega_E</code>: floats<ul> <li>See \\utils for these empirically found constants</li> </ul> </li> <li>Outputs:</li> <li>$F_{t} = \\left.\\frac{\\partial f(\\vec{x})}{\\partial \\vec{x}}\\right|{ \\vec{x}{t+\\Delta t}}$<code>eval_JacobianH()</code>:</li> </ul> <p>eval_JacobianH() (function): Uses and evaluates at the predicted prior state, the symbolic Jacobians from <code>utils/</code>, to transform the vector from state-space to a lower-dimensional measurement-space representation</p> <ul> <li>Inputs:</li> <li><code>theta_R</code>:<ul> <li>The longitude of the \u2018active\u2019 satellite at the time self.t</li> </ul> </li> <li><code>R_e, omega_E</code>: floats<ul> <li>See \\utils for these empirically found constants</li> </ul> </li> <li>Outputs:</li> <li>$H_{t} = \\left.\\frac{\\partial h(\\vec{x})}{\\partial \\vec{x}}\\right|{ \\vec{x}{t}}$</li> </ul> <p>update_prior_belief() (function): Incorporates uncertainty in equations of motion and the current state\u2019s computed process matrix to find the covariance matrix of the predicted prior state vector</p> <ul> <li><code>JacobianF</code>: np.array</li> <li>Output of evaluation</li> <li>Inputs:</li> <li><code>process_covariance</code>: np.array<ul> <li>This is the process covariance matrix $Q$. This is a measure of our \u2018belief\u2019 in the physics/ in the validity of the model of the dynamics</li> </ul> </li> <li><code>posterior_state_covariance</code>: np.array<ul> <li>$\\bar{P}t = F_t \\,P{t-\\Delta t}\\, F_t^T  (+ Q)$</li> </ul> </li> <li><code>JacobianV</code> :<ul> <li>See functionality extension for significance</li> </ul> </li> <li><code>verbose</code>: Bool<ul> <li>If True output</li> </ul> </li> </ul> <p>kalman_gain() (function): Kalman update step, which will act to scale the residual based on the strength of belief in the measurement</p> <p>predict_state() (function): Uses Kalman gain matrix to combine residual with predicted prior estimate to form a mean predicted state vector and corresponding covariance matrix</p> <p>forecast() (function): Samples are possible from the current posterior of the predicted state vector and propagate them using a numerical method to \u2018project\u2019 the current predicted posterior on Earth\u2019s surface.</p>"},{"location":"cfg/#4-visualiserpy","title":"4. <code>Visualiser.py</code>","text":"<p>The\u00a0<code>Visualiser</code>\u00a0class visualises satellite orbit decay using Cartopy maps, height vs time plots, and crash longitude distributions. It supports static plots, animations, and customizable styles.</p> <p>Visualiser (Class)</p> <ul> <li>inputs:</li> <li><code>times</code>: np.array<ul> <li>Time points (in seconds) corresponding to the satellite\u2019s trajectory.</li> </ul> </li> <li><code>trajectory_cartesian</code>: np.array<ul> <li>Satellite trajectory in Cartesian coordinates (x, y, vx, vy) in meters and meters per second.</li> </ul> </li> <li><code>trajectory_LLA</code>: np.array<ul> <li>Satellite trajectory in Latitude, Longitude, Altitude (LLA) coordinates, with latitude and longitude in degrees and altitude in meters.</li> </ul> </li> <li><code>crash_lon_list</code>: np.array<ul> <li>List of predicted crash longitudes (in degrees) for each forecast step.</li> </ul> </li> </ul> <p><code>_adjust_crash_lon_list</code> (Function)</p> <ul> <li>inputs:</li> <li><code>crash_lon_list</code>: np.array<ul> <li>Array of crash longitude predictions with shape [sets, samples, dims].</li> </ul> </li> <li><code>target_length</code>: int<ul> <li>Desired length of the crash longitude list, equal to the length of times.</li> </ul> </li> <li>outputs:</li> <li><code>adjusted_list</code>: np.array<ul> <li>Array of crash longitudes adjusted to match the target length by repeating or extending prediction sets.</li> </ul> </li> </ul> <p><code>plot_height_vs_time</code> (Function)</p> <ul> <li>inputs:</li> <li><code>figsize</code>: tuple = (8, 6)<ul> <li>Figure size (width, height) in inches.</li> </ul> </li> <li><code>title</code>: str = 'Predictor altitude estimate against time'<ul> <li>Title of the plot.</li> </ul> </li> <li><code>title_fontsize</code>: int = 14<ul> <li>Font size for the plot title.</li> </ul> </li> <li><code>label_fontsize</code>: int = 12<ul> <li>Font size for axis labels.</li> </ul> </li> <li><code>tick_fontsize</code>: int = 10<ul> <li>Font size for tick labels.</li> </ul> </li> <li><code>line_color</code>: str = 'blue'<ul> <li>Color of the altitude line.</li> </ul> </li> <li><code>line_width</code>: float = 2<ul> <li>Width of the altitude line.</li> </ul> </li> <li><code>show_grid</code>: bool = True<ul> <li>Whether to display a grid on the plot.</li> </ul> </li> <li><code>show_legend</code>: bool = True<ul> <li>Whether to display a legend.</li> </ul> </li> <li>outputs:</li> <li>None<ul> <li>Displays a plot of altitude versus time with a termination line.</li> </ul> </li> </ul> <p><code>plot_orbit_map</code> (Function)</p> <ul> <li>inputs:</li> <li><code>figsize</code>: tuple = (8, 6)<ul> <li>Figure size (width, height) in inches.</li> </ul> </li> <li><code>title</code>: str = 'Satellite Orbital Decay Trajectory'<ul> <li>Title of the plot.</li> </ul> </li> <li><code>title_fontsize</code>: int = 14<ul> <li>Font size for the plot title.</li> </ul> </li> <li><code>tick_fontsize</code>: int = 10<ul> <li>Font size for tick labels.</li> </ul> </li> <li><code>path_color</code>: str = 'red'<ul> <li>Color of the orbit path.</li> </ul> </li> <li><code>start_marker_color</code>: str = 'green'<ul> <li>Color of the start position marker.</li> </ul> </li> <li><code>end_marker_color</code>: str = 'red'<ul> <li>Color of the end position marker.</li> </ul> </li> <li><code>marker_size</code>: int = 10<ul> <li>Size of start and end markers.</li> </ul> </li> <li><code>scatter_size</code>: int = 50<ul> <li>Size of scatter points representing altitude.</li> </ul> </li> <li><code>cmap</code>: str = 'viridis'<ul> <li>Colormap for altitude scatter points.</li> </ul> </li> <li><code>show_legend</code>: bool = True<ul> <li>Whether to display a legend.</li> </ul> </li> <li>outputs:</li> <li>None<ul> <li>Displays a Cartopy map showing the satellite\u2019s orbit path with altitude-colored scatter points.</li> </ul> </li> </ul> <p><code>plot_crash_distribution</code> (Function)</p> <ul> <li>inputs:</li> <li><code>figsize</code>: tuple = (8, 6)<ul> <li>Figure size (width, height) in inches.</li> </ul> </li> <li><code>title</code>: str = 'Predicted crash site distribution'<ul> <li>Title of the plot.</li> </ul> </li> <li><code>title_fontsize</code>: int = 14<ul> <li>Font size for the plot title.</li> </ul> </li> <li><code>label_fontsize</code>: int = 12<ul> <li>Font size for axis labels.</li> </ul> </li> <li><code>tick_fontsize</code>: int = 10<ul> <li>Font size for tick labels.</li> </ul> </li> <li><code>box_color</code>: str = 'blue'<ul> <li>Color of the boxplot.</li> </ul> </li> <li><code>show_grid</code>: bool = True<ul> <li>Whether to display a grid on the plot.</li> </ul> </li> <li>outputs:</li> <li>None<ul> <li>Displays a boxplot of predicted crash longitudes versus forecast index.</li> </ul> </li> </ul> <p><code>plot_orbit</code> (Function)</p> <ul> <li>inputs:</li> <li><code>figsize</code>: tuple = (12, 10)<ul> <li>Figure size (width, height) in inches.</li> </ul> </li> <li><code>title_fontsize</code>: int = 14<ul> <li>Font size for subplot titles.</li> </ul> </li> <li><code>label_fontsize</code>: int = 12<ul> <li>Font size for axis labels.</li> </ul> </li> <li><code>tick_fontsize</code>: int = 10<ul> <li>Font size for tick labels.</li> </ul> </li> <li><code>map_title</code>: str = 'Satellite orbital decay trajectory'<ul> <li>Title for the map subplot.</li> </ul> </li> <li><code>height_title</code>: str = 'Altitude against time'<ul> <li>Title for the height versus time subplot.</li> </ul> </li> <li><code>crash_title</code>: str = 'Predicted crash site distribution'<ul> <li>Title for the crash distribution subplot.</li> </ul> </li> <li><code>path_color</code>: str = 'red'<ul> <li>Color of the orbit path.</li> </ul> </li> <li><code>height_line_color</code>: str = 'blue'<ul> <li>Color of the altitude line.</li> </ul> </li> <li><code>box_color</code>: str = 'blue'<ul> <li>Color of the crash distribution boxplot.</li> </ul> </li> <li><code>show_grid</code>: bool = True<ul> <li>Whether to display grids on the subplots.</li> </ul> </li> <li><code>show_legend</code>: bool = True<ul> <li>Whether to display legends on the subplots.</li> </ul> </li> <li>outputs:</li> <li>None<ul> <li>Displays a 2x2 grid with a Cartopy map, altitude versus time plot, and crash longitude distribution plot.</li> </ul> </li> </ul> <p><code>save_plot</code> (Function)</p> <ul> <li>inputs:</li> <li><code>filename</code>: str = 'orbit_decay.png'<ul> <li>Output file name for the saved plot.</li> </ul> </li> <li><code>figsize</code>: tuple = (12, 10)<ul> <li>Figure size (width, height) in inches.</li> </ul> </li> <li><code>title_fontsize</code>: int = 14<ul> <li>Font size for subplot titles.</li> </ul> </li> <li><code>label_fontsize</code>: int = 12<ul> <li>Font size for axis labels.</li> </ul> </li> <li><code>tick_fontsize</code>: int = 10<ul> <li>Font size for tick labels.</li> </ul> </li> <li><code>map_title</code>: str = 'Satellite Orbit Decay Path'<ul> <li>Title for the map subplot.</li> </ul> </li> <li><code>height_title</code>: str = 'Height vs Time'<ul> <li>Title for the height versus time subplot.</li> </ul> </li> <li><code>crash_title</code>: str = 'Predicted Crash Longitude Distribution'<ul> <li>Title for the crash distribution subplot.</li> </ul> </li> <li><code>path_color</code>: str = 'red'<ul> <li>Color of the orbit path.</li> </ul> </li> <li><code>height_line_color</code>: str = 'blue'<ul> <li>Color of the altitude line.</li> </ul> </li> <li><code>box_color</code>: str = 'blue'<ul> <li>Color of the crash distribution boxplot.</li> </ul> </li> <li><code>show_grid</code>: bool = True<ul> <li>Whether to display grids on the subplots.</li> </ul> </li> <li><code>show_legend</code>: bool = True<ul> <li>Whether to display legends on the subplots.</li> </ul> </li> <li><code>dpi</code>: int = 300<ul> <li>Resolution for the saved image.</li> </ul> </li> <li><code>bbox_inches</code>: str = 'tight'<ul> <li>Bounding box setting for saving the plot.</li> </ul> </li> <li>outputs:</li> <li>None<ul> <li>Saves a 2x2 grid plot (map, height, crash distribution) to the specified file.</li> </ul> </li> </ul> <p><code>animate_orbit</code> (Function)</p> <ul> <li>inputs:</li> <li><code>interval</code>: float = 50<ul> <li>Time between animation frames in milliseconds.</li> </ul> </li> <li><code>figsize</code>: tuple = (12, 12)<ul> <li>Figure size (width, height) in inches.</li> </ul> </li> <li><code>title_fontsize</code>: int = 14<ul> <li>Font size for subplot titles.</li> </ul> </li> <li><code>label_fontsize</code>: int = 12<ul> <li>Font size for axis labels.</li> </ul> </li> <li><code>tick_fontsize</code>: int = 10<ul> <li>Font size for tick labels.</li> </ul> </li> <li><code>map_title</code>: str = 'Satellite Orbital Decay Animation'<ul> <li>Title for the map subplot.</li> </ul> </li> <li><code>height_title</code>: str = 'Altitude against time'<ul> <li>Title for the height versus time subplot.</li> </ul> </li> <li><code>crash_title</code>: str = 'Predicted crash site distribution'<ul> <li>Title for the crash distribution subplot.</li> </ul> </li> <li><code>path_color</code>: str = 'red'<ul> <li>Color of the orbit path.</li> </ul> </li> <li><code>current_point_color</code>: str = 'red'<ul> <li>Color of the current position marker.</li> </ul> </li> <li><code>height_line_color</code>: str = 'blue'<ul> <li>Color of the altitude line.</li> </ul> </li> <li><code>crash_point_color</code>: str = 'black'<ul> <li>Color of crash site points on the map.</li> </ul> </li> <li><code>crash_box_color</code>: str = 'blue'<ul> <li>Color of the crash distribution boxplot.</li> </ul> </li> <li><code>marker_size</code>: int = 8<ul> <li>Size of markers for current position and start point.</li> </ul> </li> <li><code>scatter_size</code>: int = 50<ul> <li>Size of scatter points for altitude.</li> </ul> </li> <li><code>cmap</code>: str = 'viridis'<ul> <li>Colormap for altitude scatter points.</li> </ul> </li> <li><code>show_grid</code>: bool = True<ul> <li>Whether to display grids on the subplots.</li> </ul> </li> <li><code>show_legend</code>: bool = True<ul> <li>Whether to display legends on the subplots.</li> </ul> </li> <li><code>button_pos_replay</code>: list = [0.45, 0.05, 0.1, 0.05]<ul> <li>Position and size of the replay button [x, y, width, height].</li> </ul> </li> <li>outputs:</li> <li>None<ul> <li>Displays an animated 2x2 grid with a Cartopy map, altitude versus time plot, and crash longitude distribution, including a replay button.</li> </ul> </li> </ul>"},{"location":"cfg/#5-utility-module","title":"5. Utility Module","text":"<p>Purpose: Provides reusable constants, symbolic Jacobians, and helpers.</p> <p>Key Files</p> <ul> <li><code>global_variables.py</code>:</li> <li><code>G</code>:float = $6.6743\u00d710^{-11}$ $m^3 kg^{-1}s^{-2}$<ul> <li>Gravitational constant</li> </ul> </li> <li><code>M_e:</code> float = $5.972 \u00d7 10\u00b2$ kg<ul> <li>Mass of the Earth</li> </ul> </li> <li><code>C_d</code>: float = 2.2<ul> <li>Drag Coefficient</li> </ul> </li> <li><code>A</code>: float = $\\pi (1.77/2)^2 m^2$<ul> <li>Area of the satellite</li> </ul> </li> <li><code>m_s</code>: float = $479 kg$<ul> <li>Mass of the satellite</li> </ul> </li> <li><code>R_star</code>: float = $8.3144598 J mol^{-1}K^{-1}$<ul> <li>Universal ideal gas constant</li> </ul> </li> <li><code>g_0:</code>  float = $9.80665 m s^{-2}$<ul> <li>Gravitational acceleration at Earth\u2019s surface</li> </ul> </li> <li><code>M_molar</code>: float = $0.0289644 kg mol^{-1}$<ul> <li>Molar mass of Earth\u2019s air</li> </ul> </li> <li><code>omega_E</code>: float = $7.2921150 \u00d7 10\u207b\u2075 rad s^{-1}$<ul> <li>Angular rotation rate of the Earth</li> </ul> </li> <li><code>predictor_utilities.py</code>:   RK-style propagation and process noise helpers.</li> <li><code>analytical_F.py</code>, <code>analytical_H.py</code>:   Jacobian definitions using <code>sympy</code>.</li> </ul> <p>Customisation Tips</p> <ul> <li>Change Earth or model constants in <code>global_variables.py</code>.</li> <li>Edit symbolic expressions if model dynamics are altered.</li> </ul>"},{"location":"en/","title":"En","text":""},{"location":"en/#environment-dependencies","title":"Environment &amp; Dependencies","text":""},{"location":"en/#environment-setup","title":"Environment setup","text":"<p>To ensure smooth execution and modular usage of the project, please follow the environment setup guidelines below. The system should be compatible across platforms, but this has not been rigorously tested.</p> <p>Recommended Global Environment</p> Item Recommended Configuration Python Version Python \u2265 3.10 Operating System Windows 10/11, MacOS, or Linux Package Manager <code>pip</code> or <code>conda</code>"},{"location":"en/#module-wise-dependencies","title":"Module-wise dependencies","text":"<p>The project is designed with a modular, class-based architecture, allowing individual components (e.g., the simulator, predictor, or visualiser) to be executed or extended independently.</p> <p>We explicitly state the dependency versions to ensure long-term maintainability, prevent future compatibility issues, and support modular reuse or integration in other systems.</p> Module Path Python Version Notes Simulator <code>SkyFall/simulator/</code> \u2265 3.10 Uses <code>NumPy</code>, <code>SciPy</code>; any version \u22653.10 is sufficient for numerical solvers Predictor <code>SkyFall/predictor/</code> 3.x EKF, compatible with any modern Python 3 version Visualiser <code>SkyFall/visualisation/</code> \u2265 3.10 Uses <code>matplotlib</code>, <code>cartopy</code> (include link); tested with 3.10+ Utils <code>SkyFall/utils/</code> \u2013 Shared functions, no specific requirements"},{"location":"en/#package-wise-dependencies","title":"Package-wise dependencies","text":"<p>This project relies on several third-party Python packages for numerical integration, state estimation, visualisation and much more. Below is a complete list of dependencies used across all modules, along with module-specific usage notes and special considerations.</p> <p>Required Packages</p> <p>To use SkyFall, the following third-party packages are required. For the full list of required dependencies and their versions, please see <code>requirements.txt</code>. </p> Package Purpose Used In Modules <code>numpy</code> Core numerical computation, array operations Multiple modules <code>scipy</code> ODE solver (<code>solve_ivp</code>) <code>simulator</code>, <code>utils</code>, <code>visualiser</code> <code>matplotlib</code> Static plotting <code>visualiser</code> <code>tqdm</code> Progress bar for loops <code>visualiser</code>, <code>simulator</code> <code>sympy</code> Symbolic matrix construction (Jacobians) <code>utils/analytical_F.py</code>, <code>utils/analytical_H.py</code> <p>Note: built-in standard libraries such as <code>os</code>, <code>sys</code>, <code>datetime</code>, <code>time</code>, <code>math</code>, and <code>json</code> are also used across multiple modules, but do not require separate installation.</p>"},{"location":"ext/","title":"Ext","text":""},{"location":"ext/#extending-functionality","title":"Extending Functionality","text":""},{"location":"ext/#custom-radar-station-placement-and-visibility","title":"Custom Radar-Station Placement and Visibility","text":"<p>This section describes in-depth how to extend the simulator and predictor to work with user-defined, geographically specific radar stations. </p> <ul> <li>Defining Coverage Arcs:</li> <li><code>land_arcs_deg</code>: List[Tuple[float,float]]<ul> <li>Each tuple\u00a0<code>(lon_start, lon_end)</code>\u00a0defines an interval in degrees East of the equator where stations may be placed.</li> <li>Wrap\u2011around across the equator: if\u00a0<code>lon_end &lt; lon_start</code>, the interval wraps via \u00b1180\u00b0.</li> <li>Allocating the Radar Station Counts Proportionally:</li> <li>Compute each arc\u2019s angular length in degrees.</li> <li>For each span <code>L</code>, allocate the radar stations proportionally by setting <code>N_i = round(N_total * L/total_length)</code></li> <li>Adjusting the rounding: by letting <code>delta = N_total - sum(N_i)</code> and by adding <code>delta</code> to the arc with the largest span.</li> <li>Uniform Station Spacing within Arcs:<ul> <li>For each arc and its allocated count <code>n_i</code></li> </ul> </li> </ul> </li> <li>Uniform Radar Station Spacing within Arcs</li> <li>This step takes each land-arc interval and its allocated station count <code>n_i</code> and places stations at equal angular intervals along the arc. For an arc from <code>lo</code> to <code>hi</code>, compute:     <code>lons = np.linspace(lo, lo + ((hi - lo) % 360), n_i)</code></li> <li>The longitudes are then normalised into the $[-180 \\degree, +180 \\degree)$  and converted to radians for ECI calculations.</li> <li>For further customisability, replace the linear spacing with weighted sampling (concentrating more stations in high-risk regions).</li> <li>Visibility Half-Angle $\\beta$ Calculation:</li> <li>Assuming a maximum altitude <code>h_star</code> from which a station can still see the satellite.</li> <li>The geometry produces: $\\beta = \\arccos \\frac{R_E}{R_E + h_{star}}$</li> <li>Active Station Selection: <code>active_station</code></li> <li>This function first rotates each station\u2019s fixed longitude into the ECI frame by accounting for Earth\u2019s rotation, then computes the smallest signed angular separation between the satellite and each station.</li> <li>Inputs:<ul> <li><code>lon_sat</code>: satellite longitude (rad) in ECI frame</li> <li><code>t</code>: simulation time (s)</li> </ul> </li> <li>Outputs:<ul> <li><code>idx</code>: index of nearest station within coverage</li> <li><code>diff</code>: angular offset</li> </ul> </li> </ul>"}]}